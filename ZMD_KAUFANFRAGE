*&---------------------------------------------------------------------*
*& Report ZMD_KAUFANFRAGE
*&---------------------------------------------------------------------*
*&Dieser SAP-ABAP-Code hat den Zweck, Daten aus einer Excel-Datei zu lesen,
"sie zu verarbeiten und dann basierend auf diesen Daten einen Kaufanfrage
"in SAP zu erstellen. Erstellung des Kaufanfrages: Mit den vorbereiteten Daten
"wird der eigentliche Kaufanfrage  mit Hilfe der BAPI-Funktion BAPI BAPI_PR_CREATE erstellt.
"Insgesamt zielt der Code darauf ab, einen nahtlosen Prozess zur Erstellung
"von Kaufanfragen aus Excel-Daten in SAP bereitzustellen.
*&---------------------------------------------------------------------*
REPORT zmd_kaufanfrage.


TYPE-POOLS icon.
TABLES: pkw_rptattrib, sscrfields.  

TYPES : BEGIN OF ty_data,
          field1(15),
          field2(5),
          field3(3),
          field4(18),
          field5(4),
          field6(4),
          field7(15),
          field8(15),
          field9(15),
          field10(15),
        END OF ty_data.
DATA : gt_data TYPE TABLE OF ty_data,
       gs_data TYPE ty_data.


" Alternativen
*TYPES: BEGIN OF gty_alv,
*         light TYPE icon-id,
*         banfn TYPE  banfn,
*         bnfpo TYPE  bnfpo,
*         ekgrp TYPE  ekgrp,
*         matnr TYPE  matnr,
*         werks TYPE  ewerk,
*         lgort TYPE  lgort_d,
*         menge TYPE  bamng,
*         meins TYPE  bamei,
*         badat TYPE  badat,
*         lfdat TYPE  eindt,
*         text  TYPE char200,
*       END OF gty_alv.

*TYPES: BEGIN OF gty_table,
*         Belegnummer                   TYPE  int1,
*         Artıkel                       TYPE  int1,
*         Eınkaufsgruppe                TYPE  char20,
*         Material                      TYPE  char20,
*         Herstellungsort               TYPE  char20,
*         Lagerort                      TYPE  char20,
*         Menge                         TYPE  numc4,
*         Einheit                       TYPE  char3,
*         Anforderungsdatum             TYPE  datum,
*         Voraussichtliches_Lieferdatum TYPE  datum,
*       END OF gty_table.



DATA: BEGIN OF gs_header,
        name TYPE c LENGTH 30,
      END OF gs_header.

DATA: gt_header LIKE TABLE OF gs_header.

DATA: d_butt1 TYPE char3.                       

FIELD-SYMBOLS : <gt_data> TYPE STANDARD TABLE .

DATA: gs_alv TYPE zmd_alv1,
      gt_alv TYPE TABLE OF zmd_alv1.

DATA ok_code TYPE sy-ucomm.

DATA: gt_fieldcat TYPE lvc_t_fcat, " Field catalog table
      gs_layout   TYPE lvc_s_layo. " Layout structure

DATA: gr_ccontainer    TYPE REF TO cl_gui_custom_container,       " Der Name „custom contaıner“.
      gr_alv_container TYPE REF TO cl_gui_docking_container.      " Der Name „docker contaıner“.

DATA :gr_alv_grid      TYPE REF TO cl_gui_alv_grid.               " Der Name „docker contaıner“.
DATA: gc_custom_control_name TYPE scrfname VALUE 'CONTAINER'.     " Der Name „Custom Control“.
DATA: gt_exclude TYPE ui_functions, " Ohne Knopf
      gs_exclude TYPE ui_func.      " Ohne Knopf

SELECTION-SCREEN: BEGIN OF BLOCK bl1 WITH FRAME TITLE TEXT-t01.   
PARAMETERS: p_file TYPE pkw_rptattrib-filename.                   " Alternativen: "ibipparms-path" "rlgrap-filename"
SELECTION-SCREEN: END OF BLOCK bl1.

CLASS lcl_event_handler DEFINITION DEFERRED.
DATA gr_event_handler TYPE REF TO lcl_event_handler .

*----------------------------------------------------------------------*
*       CLASS lcl_event DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION .
    METHODS:
*hotspot control
      handle_hotspot_click FOR EVENT hotspot_click OF cl_gui_alv_grid
        IMPORTING e_row_id e_column_id es_row_no .

ENDCLASS.                    "lcl_event DEFINITION
*----------------------------------------------------------------------*
*       CLASS lcl_event IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_event_handler IMPLEMENTATION.

*Hotspot control.
  METHOD handle_hotspot_click .
*    PERFORM handle_hotspot_click USING e_row_id e_column_id es_row_no .
  ENDMETHOD .                    "handle_hotspot_click

ENDCLASS.                    "LCL_EVENT IMPLEMENTATION

SELECTION-SCREEN FUNCTION KEY 1.          

INITIALIZATION.
  MOVE 'Vorlage herunterladen'(t02) TO sscrfields-functxt_01.


AT SELECTION-SCREEN.
  IF sy-ucomm = 'FC01'.

    " Excel-Überschriften füllen
    APPEND 'Belegnummer'                    TO gt_header.
    APPEND 'Artıkel'                        TO gt_header.
    APPEND 'Eınkaufsgruppe'                 TO gt_header.
    APPEND 'Material'                       TO gt_header.
    APPEND 'Herstellungsort'                TO gt_header.
    APPEND 'Lagerort'                       TO gt_header.
    APPEND 'Menge'                          TO gt_header.
    APPEND 'Einheit'                        TO gt_header.
    APPEND 'Anforderungsdatum'              TO gt_header.
    APPEND 'Voraussichtliches Lieferdatum'  TO gt_header.

*
*    "Alternative
*    gt_header = VALUE #( ( name = 'Belegnummer'       ) ( name = 'Artıkel')
*                         ( name = 'Eınkaufsgruppe'    ) ( name = 'Material')
*                         ( name = 'Herstellungsort'   ) ( name = 'Lagerort')
*                         ( name = 'Menge'             ) ( name = 'Einheit')
*                         ( name = 'Anforderungsdatum' ) ( name = 'Voraussichtliches Lieferdatum') ).



    " Methode, mit der das Programm einen Dateipfad auswählen und importieren kann
    DATA: lv_fname    TYPE string,
          lv_filename TYPE string,
          lv_path     TYPE string,
          lv_fullpath TYPE string.

    CALL METHOD cl_gui_frontend_services=>file_save_dialog
      EXPORTING
        window_title              = 'File Directory'
        default_extension         = 'XLS'
        initial_directory         = 'C:\'
      CHANGING
        filename                  = lv_filename
        path                      = lv_path
        fullpath                  = lv_fullpath                 " Vollständiger Dateipfad
      EXCEPTIONS
        cntl_error                = 1
        error_no_gui              = 2
        not_supported_by_gui      = 3
        invalid_default_file_name = 4
        OTHERS                    = 5.
    IF sy-subrc <> 0.
      MESSAGE 'Sie müssen eine Datei auswählen.' TYPE 'S' DISPLAY LIKE 'E'.
    ENDIF.

    lv_fname = lv_fullpath.

    " Laden Sie die Excel-Datei herunter
    CALL FUNCTION 'GUI_DOWNLOAD'
      EXPORTING
        bin_filesize            = ''
        filename                = lv_fname
        filetype                = 'DAT'
      TABLES
        data_tab                = gt_data[]   "Leere Excel-Tabelle
        fieldnames              = gt_header[] "Tabelle mit Excel-Kopfzeilen
      EXCEPTIONS
        file_write_error        = 1
        no_batch                = 2
        gui_refuse_filetransfer = 3
        invalid_type            = 4
        no_authority            = 5
        unknown_error           = 6
        header_not_allowed      = 7
        separator_not_allowed   = 8
        filesize_not_allowed    = 9
        header_too_long         = 10
        dp_error_create         = 11
        dp_error_send           = 12
        dp_error_write          = 13
        unknown_dp_error        = 14
        access_denied           = 15
        dp_out_of_memory        = 16
        disk_full               = 17
        dp_timeout              = 18
        file_not_found          = 19
        dataprovider_exception  = 20
        control_flush_error     = 21
        OTHERS                  = 22.
    IF sy-subrc IS NOT INITIAL.
      MESSAGE 'Herunterladen ist nicht erfolgreich.' TYPE 'S' DISPLAY LIKE 'E'.
    ENDIF.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR  p_file.
  CALL FUNCTION 'F4_FILENAME'
*   EXPORTING
*     PROGRAM_NAME        = SYST-CPROG
*     DYNPRO_NUMBER       = SYST-DYNNR
*     FIELD_NAME          = ' '
    IMPORTING
    file_name = p_file.


START-OF-SELECTION.

  " Ermitteln der Erweiterung der eingegebenen Datei (TXT_TO_SAP)
*  DATA: gt_row   TYPE truxs_t_text_data,
*        lv_fname TYPE rlgrap-filename.
*
*  lv_fname = p_file.
*CALL FUNCTION 'TEXT_CONVERT_TXT_TO_SAP'
*  EXPORTING
**   I_FIELD_SEPERATOR          = ';'
*   I_LINE_HEADER              = 'x'
*    i_tab_raw_data             = gt_row[]
*   I_FILENAME                 = lv_fname
*  tables
*    i_tab_converted_data       = gt_data[]
* EXCEPTIONS
*   CONVERSION_FAILED          = 1
*   OTHERS                     = 2 .
*
*  IF sy-subrc IS INITIAL.
*    MESSAGE 'Excel-Datei konnte nicht geladen werden.' TYPE 'S' DISPLAY LIKE 'E'.
*  ENDIF.

  " Ermitteln der Erweiterung der eingegebenen Datei (XLS_TO_SAP)
  DATA: gt_row   TYPE truxs_t_text_data,
        lv_fname TYPE rlgrap-filename.

  lv_fname = p_file.


  " Erste Methode
  CLEAR gt_data[].
  CALL FUNCTION 'TEXT_CONVERT_XLS_TO_SAP'
    EXPORTING
*     I_FIELD_SEPERATOR    =
      i_line_header        = 'X'
      i_tab_raw_data       = gt_row[]
      i_filename           = lv_fname
    TABLES
      i_tab_converted_data = gt_data[]
    EXCEPTIONS
      conversion_failed    = 1
      OTHERS               = 2.

  IF sy-subrc IS NOT INITIAL.
    MESSAGE 'Excel-Datei konnte nicht geladen werden.' TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.


  " Zweite Methode (EXCEL_TO_SAP)
*  DATA: gt_itab TYPE TABLE OF alsmex_tabline.

*  CALL FUNCTION 'ALSM_EXCEL_TO_INTERNAL_TABLE'
*    EXPORTING
*      filename                = lv_fname
*      i_begin_col             = '1'
*      i_begin_row             = '2'
*      i_end_col               = '10'
*      i_end_row               = '65536'
*    TABLES
*      intern                  = gt_itab[]
*    EXCEPTIONS
*      inconsistent_parameters = 1
*      upload_ole              = 2
*      OTHERS                  = 3.
*
*  IF sy-subrc IS NOT INITIAL.
*    MESSAGE 'Excel-Datei konnte nicht geladen werden.' TYPE 'S' DISPLAY LIKE 'E'.
*  ENDIF.
*
*  LOOP AT gt_itab INTO DATA(ls_data).
*    ASSIGN COMPONENT ls_data-col OF STRUCTURE gs_data TO FIELD-SYMBOL(<lfs_fld>).
*
*    <lfs_fld> = ls_data-value.
*    AT END OF row.
*      APPEND gs_data TO gt_data.
*    ENDAT.
*  ENDLOOP.


  " Dritte Methode  (EXCEL_TO_SAP)
*  DATA : lv_filename      TYPE string,
*         lt_records       TYPE solix_tab,
*         lv_headerxstring TYPE xstring,
*         lv_filelength    TYPE i.
*
*  lv_filename = p_file.
*
*  CALL FUNCTION 'GUI_UPLOAD'
*    EXPORTING
*      filename                = lv_filename
*      filetype                = 'BIN'
**      has_field_separator     = 'X'
*    IMPORTING
*      filelength              = lv_filelength
*      header                  = lv_headerxstring
*    TABLES
*      data_tab                = lt_records[]
*    EXCEPTIONS
*      file_open_error         = 1
*      file_read_error         = 2
*      no_batch                = 3
*      gui_refuse_filetransfer = 4
*      invalid_type            = 5
*      no_authority            = 6
*      unknown_error           = 7
*      bad_data_format         = 8
*      header_not_allowed      = 9
*      separator_not_allowed   = 10
*      header_too_long         = 11
*      unknown_dp_error        = 12
*      access_denied           = 13
*      dp_out_of_memory        = 14
*      disk_full               = 15
*      dp_timeout              = 16
*      OTHERS                  = 17.
*
*  CALL FUNCTION 'SCMS_BINARY_TO_XSTRING'
*    EXPORTING
*      input_length = lv_filelength
*    IMPORTING
*      buffer       = lv_headerxstring
*    TABLES
*      binary_tab   = lt_records
*    EXCEPTIONS
*      failed       = 1
*      OTHERS       = 2.
*
*  IF sy-subrc <> 0.
*    "Implement suitable error handling here
*  ENDIF.
*
*  DATA : lo_excel_ref TYPE REF TO cl_fdt_xl_spreadsheet .
*
*  TRY .
*      lo_excel_ref = NEW cl_fdt_xl_spreadsheet(
*                              document_name = lv_filename
*                              xdocument     = lv_headerxstring ) .
*    CATCH cx_fdt_excel_core.
*      "Implement suitable error handling here
*  ENDTRY .
*
*  "Get List of Worksheets
*  lo_excel_ref->if_fdt_doc_spreadsheet~get_worksheet_names(
*    IMPORTING
*      worksheet_names = DATA(lt_worksheets) ).
*
*  IF NOT lt_worksheets IS INITIAL.
*    READ TABLE lt_worksheets INTO DATA(lv_woksheetname) INDEX 1.
*
*    DATA(lo_data_ref) = lo_excel_ref->if_fdt_doc_spreadsheet~get_itab_from_worksheet(
*                                             lv_woksheetname ).
*    "now you have excel work sheet data in dyanmic internal table
*    ASSIGN lo_data_ref->* TO <gt_data>.
*  ENDIF.
*
*  BREAK-POINT.

*******************************************************************************
 

  PERFORM selec_data.
  CALL SCREEN 100.
*&---------------------------------------------------------------------*
*&      Module  STATUS_0100  OUTPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_0100 OUTPUT.
  SET PF-STATUS 'PF0100'.
  SET TITLEBAR '0100'.

  PERFORM fcat.
  PERFORM layout.
  PERFORM show_data.
ENDMODULE.
*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0100  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_0100 INPUT.

  CASE ok_code.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN 'LEAVE' OR 'EXIT'.
      LEAVE PROGRAM.
    WHEN 'SAVE'.
      PERFORM save.
  ENDCASE.

ENDMODULE.
*&---------------------------------------------------------------------*
*&      Form  SELEC_DATA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*

FORM selec_data .

  LOOP AT gt_data INTO gs_data.
    gs_alv-light = icon_yellow_light.
    gs_alv-text  = 'Die Daten sind zur Aufzeichnung bereit.'.

    gs_alv-banfn = gs_data-field1.                      "Belegnummer



*    gs_alv-bnfpo = | { gs_data-field2 ALPHA = IN } |.  "Artıkel
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = gs_data-field2
      IMPORTING
        output = gs_alv-bnfpo.

*    gs_alv-ekgrp = | { gs_data-field3 ALPHA = IN } |.  "Eınkaufsgruppe
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = gs_data-field3
      IMPORTING
        output = gs_alv-ekgrp.

*    gs_alv-matnr = | { gs_data-field4 ALPHA = IN } |.  "Material
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = gs_data-field4
      IMPORTING
        output = gs_alv-matnr.

    SELECT SINGLE matnr
      FROM mara
      INTO @DATA(lv_matnr)
      WHERE matnr EQ @gs_alv-matnr.

    IF sy-subrc IS NOT INITIAL.
      gs_alv-light = icon_red_light.
      gs_alv-text  = 'Material nicht verfügbar.'.
    ENDIF.

    gs_alv-werks = | { gs_data-field5 ALPHA = IN } |.   "Herstellungsort
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = gs_data-field5
      IMPORTING
        output = gs_alv-werks.

    SELECT SINGLE werks
    FROM marc
    INTO @DATA(lv_werks)
    WHERE matnr EQ @gs_alv-matnr
      AND werks EQ @gs_alv-werks.

    IF sy-subrc IS NOT INITIAL.
      gs_alv-light = icon_red_light.
      gs_alv-text  = 'Material-Produktionsort ist nicht definiert.'.
    ENDIF.

*    gs_alv-lgort = | { gs_data-field6 ALPHA = IN } |.  "Lagerort
    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
      EXPORTING
        input  = gs_data-field6
      IMPORTING
        output = gs_alv-lgort.

    SELECT SINGLE lgort
    FROM mard
    INTO @DATA(lv_lgort)
    WHERE matnr EQ @gs_alv-matnr
      AND werks EQ @gs_alv-werks
      AND lgort EQ @gs_alv-lgort.

    IF sy-subrc IS NOT INITIAL.
      gs_alv-light = icon_red_light.
      gs_alv-text  = 'Material-Produktionsstandort-Lager ist nicht definiert.'.
    ENDIF.

    TRANSLATE gs_data-field7 USING ',.'.
    gs_alv-menge = gs_data-field7.                      "Menge

    gs_alv-meins = CONV meins( gs_data-field8 ).        "Einheit

    gs_alv-badat = gs_data-field9+6(4) &&               "Anforderungsdatum
                   gs_data-field9+3(2) &&
                   gs_data-field9(2).

    gs_alv-lfdat = gs_data-field10+6(4) &&              "Voraussichtliches Lieferdatum
                   gs_data-field10+3(2) &&
                   gs_data-field10(2).

    APPEND gs_alv TO gt_alv.
  ENDLOOP.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  FCAT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM fcat .
  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
    EXPORTING
      i_structure_name       = 'ZMD_ALV1'
    CHANGING
      ct_fieldcat            = gt_fieldcat
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.

  IF sy-subrc IS NOT INITIAL.
    MESSAGE 'Die Feldkatalogtabelle konnte nicht erstellt werden.' TYPE 'S' DISPLAY LIKE 'E'.
  ENDIF.

  LOOP AT gt_fieldcat INTO DATA(ls_fcat).
    CASE ls_fcat-fieldname.
      WHEN 'LIGHT'.
        ls_fcat-icon    = 'X'.
        ls_fcat-coltext = 'Bedingung'.
      WHEN 'TEXT'.
        ls_fcat-coltext = 'Nachricht'.
    ENDCASE.
    MODIFY gt_fieldcat FROM ls_fcat.
    CLEAR ls_fcat.
  ENDLOOP.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  LAYOUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM layout .
  gs_layout-zebra      = 'X' .
  gs_layout-cwidth_opt = 'X'.
  gs_layout-sel_mode   = 'A'.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  SHOW_DATA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM show_data .
  IF gr_alv_grid IS INITIAL.
    " Custom Container
*    custom grid
*    create object gr_ccontainer
*      exporting
*        container_name              = gc_custom_control_name
*      exceptions
*        cntl_error                  = 1
*        cntl_system_error           = 2
*        create_error                = 3
*        lifetime_error              = 4
*        lifetime_dynpro_dynpro_link = 5
*        others                      = 6.
*
*    IF sy-subrc IS NOT INITIAL.
*      MESSAGE '„CONTAINER“ konnte nicht erstellt werden.' TYPE 'S' DISPLAY LIKE 'E'.
*    ENDIF.

    " Docker Container
    CREATE OBJECT gr_alv_container
      EXPORTING
*       parent                      =
        repid                       = sy-repid
        dynnr                       = sy-dynnr
        side                        = gr_alv_container->dock_at_left
        extension                   = 2000
*       style                       =
*       lifetime                    = lifetime_default
*       caption                     =
*       metric                      = 0
*       ratio                       = '99'
*       no_autodef_progid_dynnr     =
*       name                        =
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        lifetime_dynpro_dynpro_link = 5
        OTHERS                      = 6.

    IF sy-subrc IS NOT INITIAL.
      MESSAGE '„CONTAINER“ konnte nicht erstellt werden.' TYPE 'S' DISPLAY LIKE 'E'.
    ENDIF.

    CREATE OBJECT gr_alv_grid
      EXPORTING
        i_parent          = gr_alv_container
      EXCEPTIONS
        error_cntl_create = 1
        error_cntl_init   = 2
        error_cntl_link   = 3
        error_dp_create   = 4
        OTHERS            = 5.
    IF sy-subrc <> 0.
      MESSAGE '„CONTAINER“ konnte nicht erstellt werden.' TYPE 'S' DISPLAY LIKE 'E'.
    ENDIF.

*********************************************************************************
    " Hier kann auch ein „Feldkatalog“ erstellt werden.
*  CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
*   EXPORTING
*     I_STRUCTURE_NAME             = 'ZMD_ALV1'
*     I_BYPASSING_BUFFER           = abap_true
*    CHANGING
*      ct_fieldcat                  = gt_fieldcat
*   EXCEPTIONS
*     INCONSISTENT_INTERFACE       = 1
*     PROGRAM_ERROR                = 2
*     OTHERS                       = 3 .
*
*  IF sy-subrc IS NOT INITIAL.
*    MESSAGE 'Die Feldkatalogtabelle konnte nicht erstellt werden.' TYPE 'S' DISPLAY LIKE 'E'.
*  ENDIF.
*
*  LOOP AT gt_fieldcat INTO DATA(ls_fcat).
*    CASE ls_fcat-fieldname.
*      WHEN 'LIGHT'.
*        ls_fcat-icon = 'X'.
*        ls_fcat-coltext = 'Bedingung'.
*      WHEN 'TEXT'.
*        ls_fcat-coltext = 'Nachricht'.
*    ENDCASE.
*
*    MODIFY gt_fieldcat FROM ls_fcat.
*    CLEAR: ls_fcat.
*  ENDLOOP.

    " Auch „Layout“ kann hier erstellt werden.
*  gs_layout-zebra      = abap_true.
*  gs_layout-cwidth_opt = abap_true.
*  gs_layout-sel_mode   = 'A'.
*********************************************************************************

    " Ohne Symbolleiste
    gs_exclude = cl_gui_alv_grid=>mc_fc_detail.
    APPEND gs_exclude TO gt_exclude.

    " Erstellen einer Instanz für den Event-Handler
    CREATE OBJECT gr_event_handler .
    SET HANDLER gr_event_handler->handle_hotspot_click FOR gr_alv_grid.

    " z.B. anfängliche Sortierkriterien, anfängliche Filterkriterien, Ausschlussfunktionen
    CALL METHOD gr_alv_grid->set_table_for_first_display
      EXPORTING
        is_layout                     = gs_layout
*       IS_PRINT                      =
*       IT_SPECIAL_GROUPS             =
        it_toolbar_excluding          = gt_exclude
*       it_hyperlink                  = gt_hyper
      CHANGING
        it_outtab                     = gt_alv[]
        it_fieldcatalog               = gt_fieldcat
*       IT_SORT                       =
*       IT_FILTER                     =
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        OTHERS                        = 4.

    IF sy-subrc IS NOT INITIAL.
      MESSAGE '„ALV“ konnte nicht angezeigt werden.' TYPE 'S' DISPLAY LIKE 'E'.
    ENDIF.
  ELSE.
    CALL METHOD gr_alv_grid->refresh_table_display
* EXPORTING
* IS_STABLE =
* I_SOFT_REFRESH =
      EXCEPTIONS
        finished = 1
        OTHERS   = 2.

    IF sy-subrc IS NOT INITIAL.
      MESSAGE 'Die Bezeichnung „ALV“ konnte nicht erneuert werden.' TYPE 'S' DISPLAY LIKE 'E'.
    ENDIF.
  ENDIF.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  SAVE
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM save .

  DATA: ls_prheader  TYPE  bapimereqheader,
        lt_prheader  TYPE TABLE OF bapimereqheader,
        ls_prheaderx TYPE  bapimereqheaderx,
        lt_prheaderx TYPE  TABLE OF bapimereqheaderx,
        ls_pritem    TYPE bapimereqitemimp,
        lt_pritem    TYPE TABLE OF  bapimereqitemimp,
        ls_pritemx   TYPE bapimereqitemx,
        lt_pritemx   TYPE TABLE OF bapimereqitemx,
        ls_return    TYPE bapiret2,
        lt_return    TYPE TABLE OF bapiret2.

  DATA: lt_alv_temp TYPE TABLE OF zmd_alv1,
        lv_number   TYPE bapimereqheader-preq_no.

  " Wir prüfen auf Fehler.
  LOOP AT gt_alv TRANSPORTING NO FIELDS
                 WHERE light NE icon_yellow_light.
    EXIT.
  ENDLOOP.

  IF sy-subrc = 0.
    MESSAGE 'Die Daten enthalten Fehler.' TYPE 'E'.
  ENDIF.

  lt_alv_temp[] = gt_alv[].
  SORT lt_alv_temp BY banfn.
  DELETE ADJACENT DUPLICATES FROM lt_alv_temp COMPARING banfn.

  LOOP AT lt_alv_temp INTO DATA(ls_alv_temp).

    CLEAR: ls_prheader, ls_prheaderx.
    ls_prheader-pr_type  = 'NB'.
    ls_prheaderx-pr_type = 'X'.

    CLEAR: ls_pritem, ls_pritemx, lt_pritem, lt_pritemx.
    LOOP AT gt_alv INTO DATA(ls_alv)
                   WHERE banfn EQ ls_alv_temp-banfn.

      ls_pritem-preq_item     = ls_alv-bnfpo.
      ls_pritem-pur_group     = ls_alv-ekgrp.
      ls_pritem-material      = ls_alv-matnr.
      ls_pritem-plant         = ls_alv-werks.
      ls_pritem-store_loc     = ls_alv-lgort.
      ls_pritem-quantity      = ls_alv-menge.
      ls_pritem-unit          = ls_alv-meins.
      ls_pritem-preq_unit_iso = 'PCE'.
      ls_pritem-preq_date     = ls_alv-badat.
      ls_pritem-deliv_date    = ls_alv-lfdat.
      APPEND ls_pritem TO lt_pritem.
      CLEAR ls_pritem.

      ls_pritemx-preq_item     = ls_alv-bnfpo.
      ls_pritemx-pur_group     = abap_true.
      ls_pritemx-material      = abap_true.
      ls_pritemx-plant         = abap_true.
      ls_pritemx-store_loc     = abap_true.
      ls_pritemx-quantity      = abap_true.
      ls_pritemx-unit          = abap_true.
      ls_pritemx-preq_unit_iso = abap_true.
      ls_pritemx-preq_date     = abap_true.
      ls_pritemx-deliv_date    = abap_true.
      APPEND ls_pritemx TO lt_pritemx.
      CLEAR ls_pritemx.

    ENDLOOP.

    CALL FUNCTION 'BAPI_PR_CREATE'
      EXPORTING
        prheader  = ls_prheader
        prheaderx = ls_prheaderx
      IMPORTING
        number    = lv_number
      TABLES
        return    = lt_return
        pritem    = lt_pritem
        pritemx   = lt_pritemx.

    " Prüfen, ob in der Return Tabelle eine Fehlermeldung vorhanden ist
*  READ TABLE lt_return INTO ls_return WITH KEY type = 'S'.

    LOOP AT lt_return INTO ls_return WHERE type CA 'EAX'.
      EXIT.
    ENDLOOP.

    IF sy-subrc IS INITIAL. " Es liegt ein falscher Datensatz vor.
      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.

      " Lassen Sie uns die Felder in ALV aktualisieren.
      LOOP AT gt_alv INTO ls_alv
                    WHERE banfn EQ ls_alv_temp-banfn.
        ls_alv-light = icon_red_light.
        ls_alv-text  = ls_return-message.
        MODIFY gt_alv FROM ls_alv. " Erfolgreich
      ENDLOOP.
    ELSEIF sy-subrc IS NOT INITIAL.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
        EXPORTING
          wait = abap_true.

*      COMMIT WORK AND WAIT. " Ähnlich der Funktion BAPI_TRANSACTION_COMMIT

      "wird darauf erwartet, dass es in die Datenbank schreibt.
*    WAIT UP TO 1 SECONDS.
      DATA(lv_wait) = 0.
      DO .
        WAIT UP TO 1 SECONDS.

        lv_wait = lv_wait + 1.

        SELECT SINGLE banfn
          FROM eban
          INTO @DATA(lv_banfn)
          WHERE banfn_cs EQ @lv_number.

        IF sy-subrc IS INITIAL.
          EXIT.
        ENDIF.

        IF lv_wait = 10.
          EXIT.
        ENDIF.
      ENDDO.

      " Lassen Sie uns die Felder in ALV aktualisieren.
      LOOP AT gt_alv INTO ls_alv
                    WHERE banfn EQ ls_alv_temp-banfn.
        ls_alv-light = icon_green_light.
        ls_alv-banfn = lv_number.
        ls_alv-text  = 'Das Dokument wurde erstellt.'.
        MODIFY gt_alv FROM ls_alv. " Erfolgreich
      ENDLOOP.
    ENDIF.
  ENDLOOP.

  CALL METHOD cl_gui_cfw=>flush. " Es prüft, ob die Daten auf dem aktuellen Bildschirm aktualisiert werden können.
  CALL METHOD gr_alv_grid->refresh_table_display
*  EXPORTING
*    is_stable      =
*    i_soft_refresh =
    EXCEPTIONS
      finished = 1
      OTHERS   = 2.

  IF sy-subrc IS NOT INITIAL.
*--Exception handling
  ENDIF.
ENDFORM.
